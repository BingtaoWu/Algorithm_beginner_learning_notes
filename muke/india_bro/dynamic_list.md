### 动态列表的实现

在计算机科学中，动态列表可以通过不同的数据结构来实现。两种常见的方法是 **使用数组** 和 **使用链表**。这两种方法有各自的优点和缺点，适用于不同的场景。以下是它们的实现方式、操作、以及各自的优缺点。

---

#### 1. 使用数组实现动态列表

##### 数组的基本原理：
- **定义一个变量用于标记列表的末尾**：通常，列表的末尾会用一个变量（例如 `size` 或 `end`）来表示，这个变量记录数组中最后一个有效元素的位置。
- **初始化变量或设置为 -1**：数组索引从 0 开始，所以当数组为空时，这个变量可以初始化为 -1，表示没有有效元素。
  
##### 动态扩容：
- **数组满时动态扩容**：当数组已满时，会创建一个新的数组，大小为之前数组的两倍。接着，将之前数组中的所有元素复制到新的数组中，然后释放原数组占用的内存。这种方法确保了数组可以容纳更多元素，**但在扩容时需要额外的时间和空间**。

##### 基本操作：
- **访问**：通过索引直接访问元素，时间复杂度为 O(1)。
- **插入**：在末尾插入元素的时间复杂度为 O(1)。但在数组中间插入元素时，需要移动后面的元素，时间复杂度为 O(n)。
- **删除**：在末尾删除元素的时间复杂度为 O(1)。如果删除中间的元素，则需要移动后面的元素，时间复杂度为 O(n)。
- **添加**：当数组已满时，会动态扩容，之后再添加元素。

##### 数组的缺点：
- **空间浪费**：如果数组中的数据没有被充分利用，可能会有未使用的空间占用内存。
- **插入/删除效率低**：在插入或删除元素时，需要将后面的元素向前或向后移动，时间复杂度较高。
- **动态扩容开销**：当元素数量超过数组的大小时，需要进行数组的扩容和数据的复制，这会消耗额外的时间和空间。

---

#### 2. 使用链表实现动态列表

##### 链表的基本原理：
- **内存管理器**：链表使用动态分配的内存块，每个节点存储一个元素，并包含一个指针指向下一个节点。内存管理器负责分配和释放内存块。
- **无效地址标记**：0（或 `NULL`）通常用来表示链表的末尾，即在最后一个节点之后没有指向下一个节点的链接。
- **指针变量**：每个节点的指针用于存储下一个节点的内存地址。典型架构中，指针变量通常占用 4 个字节（32 位系统中）。

##### 基本操作：
- **访问**：需要从链表的头部开始逐个遍历节点，直到找到目标元素，时间复杂度为 O(n)。
- **插入**：在链表的头部或中间插入元素的时间复杂度为 O(1)，因为不需要移动元素，只需修改指针。
- **删除**：在链表中删除元素时的时间复杂度为 O(1)，如果知道要删除的节点，只需修改指针。不需要像数组那样移动其他元素。
- **添加**：链表的添加操作与插入类似，在末尾或中间添加节点的时间复杂度为 O(1)。

##### 链表的优缺点：
- **内存使用灵活**：链表的内存使用更高效，因为它只会在需要时动态分配内存，不会浪费内存空间。
- **插入/删除高效**：在链表中进行插入和删除操作比数组更高效，因为不需要移动其他元素，只需调整指针。
- **访问效率低**：链表的访问效率较低，因为无法通过索引直接访问元素，需要遍历整个链表，时间复杂度为 O(n)。
- **内存开销大**：链表中的每个节点除了存储数据之外，还需要额外的内存空间来存储指针，增加了内存开销。

---

### 总结

| 实现方式   | 优点                                           | 缺点                                                   |
|------------|------------------------------------------------|--------------------------------------------------------|
| **数组**   | - 快速访问，O(1)<br>- 插入/删除末尾操作高效    | - 空间浪费<br>- 插入/删除需要移动元素<br>- 动态扩容开销 |
| **链表**   | - 灵活的内存使用<br>- 插入/删除高效，不需要移动 | - 访问效率低，需要遍历节点<br>- 额外的指针存储开销      |

#### 适用场景：
- **数组**：适合需要频繁读取和按索引访问元素的场景，尤其是元素数量稳定的情况。
- **链表**：适合需要频繁插入和删除操作的场景，尤其是数据规模变化较大，且无需频繁按索引访问元素的场景。

通过上面的对比可以看到，数组和链表在动态列表中的实现各有优劣。选择哪种结构要根据具体的应用需求来决定。如果需要快速随机访问，数组是更好的选择；而在频繁插入删除的场景中，链表更为合适。
```cpp
struct node {
    int data;
    node* next;
};
```

c语言中的作用域
局部变量
生命周期
利用全局变量传递数据
```c
#include <stdio.h>
#define pi 3.14
float s;
void area_circle(float r){
    s = pi * r *r;
    return;
}
int main(){
    float r1,r2,s1,s2,s0;
    printf("enter the radius of the first circle\n");
    scanf("%f%f",&r1,&r2);
    area_circle(r1);
    s1 = s;
    area_circle(r2);
    s2 = s;
    s0 = s1 - s2;
    printf("the area of the first circle is %f\n",s1);
    printf("the area of the second circle is %f\n",s2);
    printf("the area of the two circular ring is %f\n",s0);
    return 0;
}

```
使用全局变量传递数据的缺点
1. 全局变量在函数中可以随意修改，容易导致数据混乱和不一致。
2. 提高了函数之间的耦合性,也就是说函数之间容易相互影响
同名变量的屏蔽
```c
#include <stdio.h>
int a = 10;
int main(void){
    {
        int a = 20;
        printf("内层的a%d\n",a);
    }
    printf("外层的a%d\n",a);
    return 0;
}
```

程序的执行
解释和编译